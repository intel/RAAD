{
    "anomaly_threshold": "5.0",
    "app_description": "Intel Labs Control Flag \nWhat\u2019s New: Today, Intel unveiled ControlFlag \u2013 a machine programming research system that can autonomously detect errors in code. Even in its infancy, this novel, self-supervised system shows promise as a powerful productivity tool to assist software developers with the labor-intensive task of debugging. In preliminary tests, ControlFlag trained and learned novel defects on over 1 billion  unlabeled lines of production-quality code. Why It Matters: In a world increasingly run by software, developers continue to spend a disproportionate amount of time fixing bugs rather than coding. It\u2019s estimated that of the $1.25 trillion that software development costs the IT industry every year, 50 percent is spent debugging code1. Debugging is expected to take an even bigger toll on developers and the industry at large. As we progress into an era of heterogenous architectures \u2014 one defined by a mix of purpose-built processors to manage the massive sea of data available today \u2014 the software required to manage these systems becomes increasingly complex, creating a higher likelihood for bugs. In addition, it is becoming difficult to find software programmers who have the expertise to correctly, efficiently and securely program across diverse hardware, which introduces another opportunity for new and harder-to-spot errors in code. When fully realized, ControlFlag could help alleviate this challenge by automating the tedious parts of software development, such as testing, monitoring and debugging. This would not only enable developers to do their jobs more efficiently and free up more time for creativity, but it would also address one of the biggest price tags in software development today. How It Works: ControlFlag\u2019s bug detection capabilities are enabled by machine programming, a fusion of machine learning, formal methods, programming languages, compilers and computer systems. ControlFlag specifically operates through a capability known as anomaly detection. As humans existing in the natural world, there are certain  patterns we learn to consider 'normal' through observation. Similarly, ControlFlag learns from verified examples to detect normal coding patterns, identifying anomalies in code that are likely to cause a bug. Moreover, ControlFlag can detect these anomalies regardless of programming language. A key benefit of ControlFlag\u2019s unsupervised approach to pattern recognition is that it can intrinsically learn to adapt to a developer\u2019s style. With limited inputs for the control tools that the program should be evaluating, ControlFlag can identify stylistic variations in programming language, similar to the way that readers recognize the differences between full words or using contractions in English. The tool learns to identify and tag these stylistic choices and can customize error identification and solution recommendations based on its insights, which  minimizes ControlFlag\u2019s characterizations of code in error that may simply be a stylistic deviation between two developer teams. Intel has even started evaluating using ControlFlag internally to identify bugs in its own software and firmware product development. It is a key element of Intel\u2019s Rapid Analysis for Developers project, which aims to accelerate velocity by providing expert assistance.\nVideo: https://vimeo.com/intelpr/review/486109038/360d4e62c8 \nCitation: https://arxiv.org/abs/2011.03616\n\n",
    "app_epilog": "Anomalous toolkit API used to mine or scan C/C++ code signatures\n",
    "currentTime": "2021-06-11-15-44-14-916555\n",
    "dataCurrentTime": "CurrentTime-Info",
    "dataInfoExtract": "Inputs-Mine",
    "dataProfile": "App-Control_Flag-Info",
    "dataThread": "Scan-Output",
    "debug": "False",
    "directory_to_scan_for_anomalous_patterns": "",
    "directory_to_scan_for_anomalous_patterns_default": "../../../../ADP/nand/gen3/src",
    "faultSave": "False",
    "max_cost_for_autocorrect": "2",
    "max_number_of_results_for_autocorrect": "5",
    "menuOptions": "Save",
    "mineThreadActive": "Mine thread status is: waiting for inputs\n",
    "more": "False",
    "number_of_processes_to_use_for_mining": "1",
    "number_of_scanning_threads": "1",
    "outputMine": "[2021-06-11-15-44-03-905102] Intel Labs Control Flag Code Miner v1.0[NOTICE] Summary File /home/jdtarang/raad/machine_programming_research/projects/controlflag/data/tmp_results_mine/2021-06-11-15-43-27-168538_exte4c_n_summaryFile.ts.\nThread results:\nNil\nMine thread status is: thread execution complete at 2021-06-11-15-44-03-904008 with status code 0\n\n",
    "outputScan": "Scan=Nil\n",
    "output_directory_to_store_training_data": "",
    "output_directory_to_store_training_data_default": "tmp_results_training",
    "output_file_to_store_training_data": "../../../../ADP/nand/gen3/src",
    "output_log_dir": "",
    "output_log_dir_default": "../data/tmp_results_anomalies",
    "scanThreadActive": "Scan thread status is: waiting for inputs\n",
    "timeout": "172800",
    "training_data": "../data/c_lang_if_stmts_6000_gitrepos.ts",
    "tree_depth": "100"
}