#!/usr/bin/python3
# -*- coding: utf-8 -*-
# *****************************************************************************/
# * Authors: Randal Eike, Andrea Chamorro, Joseph Tarango
# *****************************************************************************/
# Script Name   : parserTwidlGen.py
# Purpose       : Implements specific instantiation of "parser[FORMAT-TYPE]Gen" script which generates ctypes for interfacing with TWIDL tools.
# Version       : 1.0
# #############################################################################
from __future__ import absolute_import, division, print_function, unicode_literals  # , nested_scopes, generators, generator_stop, with_statement, annotations
# General Python module imports
import os

# Token objects
from src.software.parse.autoObjects import dataElement
from src.software.parse.autoObjects import structDef
from src.software.parse.autoObjects import objectDefine
from src.software.parse.autoObjects import ctypedef
from src.software.parse.autoObjects import outputGenerationHelper


class twidlParserFileGenerator(object):
    def __init__(self, abspath, uid, twidlDir= None):
        self.absPath = abspath
        self.filename = uid
        self.twidlDir = twidlDir
        self.importList = []
        self.classList = []
        self.currentOutputFile = None

    def __openfile(self):
        outputFileName = os.path.join(self.absPath, self.filename+".py")
        self.currentOutputFile = open(outputFileName, "wt")

    def __closeFile(self):
        self.currentOutputFile.close()
        self.currentOutputFile = None

    def __write(self, outStr):
        if (self.currentOutputFile is not None): self.currentOutputFile.write(outStr)
        else: print(outStr)

    def addImport(self, importFileName, importName):
        duplicate = False
        for existingFileName, existingName in self.importList:
            if ((existingFileName == existingFileName) and (importName == existingName)):
                duplicate = True
                break

        if (False == duplicate): self.importList.append((importFileName, importName))

    def addClassDef(self, structName, structType, fieldList, size = 0, majorVersion = 0, minorVersion = 0):
        if (structType == "union"):
            className = format("%s_v%d_%d_union" % (structName, majorVersion, minorVersion))
            baseType = "Union"
        else:
            className = format("%s_v%d_%d_structure" % (structName, majorVersion, minorVersion))
            baseType = "Structure"
            size = -1

        # Don't add it if it's already in the system
        duplicate = False
        for existingName, existingType, existingList, existingSize in self.classList:
            if (className == existingName):
                duplicate = True
                break

        if (False == duplicate): self.classList.append((className, baseType, fieldList, size))
        return className

    def __outputClassData(self, fieldList, classname, classType, unionSize = 0):
        self.__write(format("class %s(%s):\n" % (classname, classType)))
        self.__write(format("    \"\"\"\n"))
        self.__write(format("    %s() - auto generated struct class\n" % (classname)))
        self.__write(format("    \"\"\"\n"))

        self.__write(format("    _pack_    = 1\n"))
        self.__write(format("    _fields_  = [\n"))
        for fieldName, fieldType, docstr in fieldList:
            memberName = format("\"%s\"" % (fieldName))
            self.__write(format("                 (%-40s, %s),\n" % (memberName, fieldType)))

        self.__write(format("                ]\n\n"))
        return classname

    def generateFile(self):
        self.__openfile()

        # Output default header
        self.__write("\"\"\"\n")
        self.__write("This file is automatically generated per Telemetry object.  Please do not modify.\n")
        self.__write("\"\"\"\n\n")
        self.__write("# General imports\n")
        self.__write("from ctypes import *\n")
        self.__write("import sys\n")
        if self.twidlDir is not None:
            self.__write("sys.path.append('%s')\n"%self.twidlDir)
        #self.__write("from twidl_struct import TWIDL_Structure, TWIDL_Union\n")
        #self.__write("from util.utility import buf_read16, bytesToStr\n\n")

        # Output the additional includes
        self.__write("# Substructure imports\n")
        for importFileName, importName in self.importList:
            self.__write(format("from %s import %s\n" % (importFileName, importName)))

        self.__write("\n# Class definitions\n\n")
        for className, baseType, fieldList, size in self.classList:
            classDefinitionStr = self.__outputClassData(fieldList, className, baseType, size)

        self.__closeFile()
        return self.filename, classDefinitionStr


class parserTwidlGenerator(outputGenerationHelper):
    subdirName = "twidlparser"
    nameSeparator = "_"

    def __init__(self):
        self.absPath = None
        self.importDict = dict()
        return super(parserTwidlGenerator, self).__init__()

    def __addMemberDecription(self, member, workingDefList, basename = None, fileGenerator = None):
        substruct = member.getSubstruct()

        if (substruct is not None):
            subStructName = substruct.getName()
            memberName = member.getName()

            if ((-1 != subStructName.find("__")) or (subStructName[0] == "_") or (substruct.isBitFieldType()) or (substruct.isInline())):
                # process the structure inline
                substructMembers = self.__generateClassDescription(substruct, basename, fileGenerator)
                if (fileGenerator is not None):
                    # Add the internal class definition
                    majorVer = substruct.getMajorVersion()
                    minorVer = substruct.getMinorVersion()
                    size = substruct.getSize()
                    ctypeName = fileGenerator.addClassDef(subStructName, substruct.getTwidlType(), substructMembers, size, majorVer, minorVer)
                    workingDefList.append((memberName, ctypeName, None))
                else:
                    # No file generator or special name (_name) or only one member in the structure
                    for memberName, ctypeName, docStr in substructMembers:
                        memberName = subStructName + parserTwidlGenerator.nameSeparator + memberName
                        workingDefList.append((memberName, ctypeName, docStr))
            else:
                # process the external structure
                if (basename is not None): substructBaseName = basename + parserTwidlGenerator.nameSeparator + memberName
                else: substructBaseName = memberName
                ctypeName = self.__generateFileDesc(substruct, substructBaseName, fileGenerator)
                workingDefList.append((memberName, ctypeName, None))
        else:
            # Non-structure definition
            name, docStr, ctypeName = member.getCtypeType()
            workingDefList.append((name, ctypeName, docStr))


    def __generateStructMemberDescription(self, workingDescList, inputStruct, basename = None, fileGenerator = None):
        # Go through the members
        for member in inputStruct.getMemberList():
            self.__addMemberDecription(member, workingDescList, basename, fileGenerator)

    def __generateClassDescription(self, inputStruct, basename = None, fileGenerator = None):
        workingDescList = []
        structType = inputStruct.getStructType()
        self.__generateStructMemberDescription(workingDescList, inputStruct, basename, fileGenerator)
        return workingDescList

    def __generateFileDesc(self, structEntry, baseName = None, parentGenerator = None, objEntry= None):
        structName = structEntry.getName()
        fileGenerator = twidlParserFileGenerator(self.absPath, structName)

        memberList = self.__generateClassDescription(structEntry, baseName, fileGenerator)
        fileGenerator.addClassDef(structName, structEntry.getTwidlType(), memberList, structEntry.getSize(), structEntry.getMajorVersion(), structEntry.getMinorVersion())

        importFileName, importName = fileGenerator.generateFile()

        if objEntry:
            uidNum = objEntry.getUid()
            self.addImport(uidNum, importFileName, importName, structEntry.getTwidlType())

        if (parentGenerator is not None): parentGenerator.addImport(importFileName, importName)

        return importName

    def addImport(self, uidNum, importFileName, importName, twidlType):
        if not self.importDict.get(uidNum):
            self.importDict[uidNum] = (importFileName, importName, twidlType)

    def CreateFiles(self, objList, outputDir = None):
        # Create the path
        if (outputDir is not None): absPath = os.path.abspath(outputDir)
        else: absPath = os.path.abspath(os.path.join(".", parserTwidlGenerator.subdirName))

        # Check if it exists
        if (not os.path.exists(absPath)): os.makedirs(absPath)
        self.absPath = absPath

        for objEntry in objList:
            # Generate an ordered list
            objStruct = objEntry.getObjStruct()
            self.__generateFileDesc(objStruct, objEntry = objEntry)

        print ("dict:", self.importDict)
        return self.importDict








